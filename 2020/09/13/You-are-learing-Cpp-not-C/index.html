<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=0"><meta name="description" content="你学的是C++而不是C [ arrayJY ] "><meta name="theme-color" content="#6ba8a9"><title>你学的是C++而不是C [ arrayJY ] </title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/highlight.min.js" defer></script><script src="/js/paper.js" defer></script><script src="https://www.googletagmanager.com/gtag/js?id=xx-xxxxxxx-xx" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'xx-xxxxxxx-xx');</script><link rel="stylesheet" href="/css/tocbot.css"><script src="/js/tocbot.js" defer></script><script>window.addEventListener('DOMContentLoaded', () => {
  tocbot.init({
    // Where to render the table of contents.
    tocSelector: '.toc__content',
    // Where to grab the headings to build the table of contents.
    contentSelector: '.article__content',
    // Which headings to grab inside of the contentSelector element.
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    // For headings inside relative or absolute positioned containers within content.
    hasInnerContainers: true,
    orderedList: false,
    collapseDepth: 2,
  });
})</script><link rel="preload" href="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.6.0/styles/github.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.6.0/styles/github.min.css"><link rel="preload" href="https://fonts.googleapis.com/css?family=Abril+Fatface&amp;display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface&amp;display=swap"><meta name="generator" content="Hexo 5.1.1"></head><body><div class="mask-border"></div><div class="head"><div class="head__inner"><h1><a href="/">arrayJY</a></h1><p></p></div></div><div class="paper-container"><div class="main"><div class="location-bar"><div class="line-1"><div class="horizontal-line" style="height: 3px"></div></div><div class="line-2"><div class="horizontal-line" style="height: 1px"></div></div><p class="text">你学的是C++而不是C</p><div class="switch-button"><input class="container_toggle" type="checkbox" id="switch" name="mode"><label for="switch">Toggle</label></div><div class="line-3"><div class="horizontal-line" style="height: 1px"></div></div></div><div class="main__2-col"><article class="post-view__article"><div class="article__infomation"><div class="posts-item"><h2 class="posts-item__title"><a href="">你学的是C++而不是C</a></h2><span class="post__date">2020-09-13</span></div></div><div class="article__content"><p>如果是你是个计算机系学生，你所在的大学正在教授你C++，那么很多时候你不得不重新审视你学到的知识——你真的在学C++吗？</p>
<a id="more"></a>
<p>诸多大学采用他们自编的、粗制滥造的教材（最著名的比如谭某某的教材），试图将似C非C的C++灌输到学生脑子当中。如果你有那么一点追求，就应该扔掉手里的教材，换一本至少知道自己在讲什么的东西。</p>
<p>本文目的就是指出那些教材中的C式C++写法，并教你如何用<strong>Modern C++</strong> 代替他们，从而放弃混账的C式C++。<strong>请注意，本文不是一本完整教授C++的教程。</strong></p>
<p><strong>本文适合：C++初学者、被学校C式C++折磨得不耐烦的人、对自己的C++技术有追求的人。</strong><br><strong>本文不适合：有一定基础、有自己学习方法的人。</strong></p>
<p>推荐C++入门书籍：<br><em>《C++ Primer 5th》《Think in C++》</em><br>推荐网站：<br><a target="_blank" rel="noopener" href="https://google.com/">Google</a>，<a target="_blank" rel="noopener" href="https://zhihu.com/">知乎</a>，<a target="_blank" rel="noopener" href="https://zh.cppreference.com/">C++参考手册</a>，<a target="_blank" rel="noopener" href="https://stackoverflow.com/">Stackoverflow</a>，<a target="_blank" rel="noopener" href="https://github.com/">Github</a><br>上不去就自己想办法，翻墙不是难事。</p>
<p><strong>本文很长，可以慢慢看，可以看一半就放弃，可以看到这句话就走。</strong></p>
<h3 id="0x00-为什么你要学C"><a href="#0x00-为什么你要学C" class="headerlink" title="0x00 为什么你要学C++"></a>0x00 为什么你要学C++</h3><p>你看到这个问题时，脑子里可能很快蹦出一个答案：因为考试要考。我当然知道你要考，我也要考，但我们的人生不是为了考试，对吗？你必须得知道，C++到底对你来说意味着什么。</p>
<h4 id="一、对于编程初学者，C-不是一门好的语言"><a href="#一、对于编程初学者，C-不是一门好的语言" class="headerlink" title="一、对于编程初学者，C++不是一门好的语言"></a>一、对于编程初学者，C++不是一门好的语言</h4><p>如果你初学编程，C++对你来说可能是<strong>很枯燥、很繁琐</strong>的一门语言。它包含了大量的细节、需要你拥有几乎无穷多的计算机知识才能解决的问题，以及繁复的语法。</p>
<p>如果你试着用Python入门编程，你可能会惊呼：编程为什么这么简单！</p>
<p>但是C++给予了你以下机会：</p>
<ul>
<li>近乎无限接近于程序运作的底层原理</li>
<li>近乎可以掌控一切细节</li>
<li>可以在一门语言中实践各种<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%9E%8B">编程范式</a></li>
</ul>
<p>有了这些机会，当你在学习其他计算机知识，或者其他编程语言时感到有如天助。</p>
<p><em>这是我个人的真实例子，那时我对C++的了解不过是看过一本入门书籍，写过不到千行代码。但当我有一天准备学习Python时，我仅用了一个晚上就看完了Python的所有语法。</em></p>
<p>如果你对以上的内容毫无兴趣，很明显，<strong>这篇文章不是为你写的，你可以无需在此浪费时间了。</strong></p>
<h4 id="二、“视C-为一个语言联邦”"><a href="#二、“视C-为一个语言联邦”" class="headerlink" title="二、“视C++为一个语言联邦”"></a>二、“视C++为一个语言联邦”</h4><p>“视C++为一个语言联邦”出自<em>《Effective C++》</em>的条款01，这本书被认为是C++进阶书籍，但是这一条，我认为C++初学者也应该了解它。</p>
<p>简单讲讲C++的历史（我也很烦历史，但你不了解他你就不知道我接下来讲的是啥）：</p>
<p>C++一开始是作为C语言的拓展出现的，一开始它的名字叫<em>C with classes(带类的C)</em> 。后来人为了能让它胜任各种工作，往它上面加了各种杂七杂八的功能，这使得C++变得非常复杂，像是多门小语言组成的一个语言联邦。很多时候你不得不在各种“小语言”模式中切换，而这对初学者而言简直是个噩梦。但你必须了解它，而且其实你也不难适应它。</p>
<p>这门语言联邦主要包含：</p>
<ul>
<li>C，这简直是废话，作为C语言的拓展C++肯定要兼容C语言，<strong>但是这不是学校把C++当成C教的理由</strong>。</li>
<li>C with classes，一个支持面向对象的C，<strong>学校几乎是从C不明不白的跳到了这里，让人云里雾里。</strong></li>
<li>Template，模板，<strong>作为初学者，我们可以几乎不用管这个</strong>，等你有一定基础之后再来学习。</li>
<li>STL，全称为<em>Standard Template Library(标准模板库)</em> ，<strong>作为初学者，这是你学C++的利器，但是学校几乎不教它。</strong></li>
</ul>
<p>本文将着重于<strong>面向对象入门和STL的使用</strong>，相信我，一定会讲的很有趣。</p>
<p>本文写于<strong>2020年3月17日</strong>，此时C++标准已经发展到<em>C++20</em>（此前还有<em>C++98、C++11、C++14和C++17</em>)，许多学校还在可怜地对着<em>C++98</em>抱残守缺，而新的标准带来了许许多多好用的工具（无论对C++初学者还是熟练使用C++的人），所以请你<strong>一定要跟上时代的步伐</strong>，不要做一个考古学家，至少，从<em>C++11</em>开始。</p>
<h3 id="0x01-从选一个现代IDE开始"><a href="#0x01-从选一个现代IDE开始" class="headerlink" title="0x01 从选一个现代IDE开始"></a>0x01 从选一个现代IDE开始</h3><p>很多学校还在教授<em>Visual C++ 6.0</em>这个快要入土为安的东西，它开发于<strong>1998年</strong>，至今已有<strong>22年</strong>的历史。22年！海都枯了，石都烂了。我们完全可以用更好的、更先进的IDE，不是吗？我们不是考古学家，更不是山顶洞人。</p>
<p>推荐如下IDE：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://visualstudio.microsoft.com/zh-hans/">Visual Studio</a></p>
<p>这是Window上写代码的不二选择，但它更偏向于大型工程，对于初学者而言，<strong>太重了</strong>。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.jetbrains.com/clion/">CLion</a></p>
<p>Mac/Linux用户的选择，当然Windows上也可以用。然而它是收费软件，不过学生可以申请免费使用。<strong>适合初学者。</strong></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://code.visualstudio.com/">Visual Studio Code</a> + <a target="_blank" rel="noopener" href="https://clang.llvm.org/">Clang</a></p>
<p>VSCode是严格来说不算IDE，只是一个文本编辑器，加上Clang编译器也只能说刚刚好。<strong>特点是轻巧，对于初学者完全足够</strong>。配置起来比较复杂，可以参考<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/30315894/answer/154979413">知乎：Visual Studio Code 如何编写运行 C、C++ 程序？</a>。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.apple.com/xcode/">XCode</a> + <a target="_blank" rel="noopener" href="https://clang.llvm.org/">Clang</a></p>
<p>理由同VSCode，只是VSCode在Mac上算是个残次品，XCode也只能算勉强能用。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.codeblocks.org/">Code::Blocks</a></p>
<p>这个我没有用过，不好评价。但至少它一直在更新。</p>
</li>
</ul>
<p>如果上面的你都觉得不好用，你还可以用<strong>Dev-C++</strong> ，这个简单易用，但它已经停止更新了，它只支持到<em>C++11</em>标准。</p>
<p>现代的IDE带有大量工具，比如代码补全、调试，可以快速帮我们写程序，或者找出程序错误的地方。这些工具都十分有用，<strong>学着使用他们，搜索引擎可以帮你的忙。</strong></p>
<h3 id="0x02-使用-const-而不是-define定义常量"><a href="#0x02-使用-const-而不是-define定义常量" class="headerlink" title="0x02 使用 const 而不是 #define定义常量"></a>0x02 使用 <code>const</code> 而不是 <code>#define</code>定义常量</h3><p>远古时期的C语言没有<code>const</code>常量的概念，那时候人们喜欢用<code>#define</code>来定义一个符号常量，比如像这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PI 3.14</span><br><span class="hljs-keyword">int</span> r = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">double</span> s = r * r * PI;<br></code></pre></td></tr></table></figure>

<p>以上出现在大量<strong>C++教材</strong>中的例子，不知道为什么，这些教材的编写者喜欢把C的东西带入到C++中。在C++里你完全可以使用<code>const</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> PI = <span class="hljs-number">3.14</span>;<br><span class="hljs-keyword">int</span> r = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">double</span> s = r * r * PI;<br></code></pre></td></tr></table></figure>

<p>使用 <code>const</code> 常量而不是 符号常量原因有二：</p>
<ol>
<li><code>const</code>常量有生命周期（后文我们会详细讨论这个概念）而符号常量没有。</li>
<li>在编译期，编译器会对<code>const</code>常量做类型检查。</li>
</ol>
<p>这两个原因可以让<code>const</code>常量变得安全高效。</p>
<h3 id="0x03-使用-auto-自动推断类型"><a href="#0x03-使用-auto-自动推断类型" class="headerlink" title="0x03 使用 auto 自动推断类型"></a>0x03 使用 <code>auto</code> 自动推断类型</h3><p>在后面，我们会看到一些名字很长很长很长的类型（STL里面就有很多），如果我们为了代码整洁美观，也为了少打几个字，可以使用<code>auto</code>自动推断类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;    <span class="hljs-comment">//定义一个int变量</span><br><span class="hljs-keyword">auto</span> b = <span class="hljs-number">1.0</span>; <span class="hljs-comment">//自动推断b为double变量</span><br></code></pre></td></tr></table></figure>

<p>使用<code>auto</code>还有一个好处，就是可以防止使用未初始化的变量：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> a;<br><span class="hljs-built_in">cout</span> &lt;&lt; a; <span class="hljs-comment">//warning: variable &#x27;a&#x27; is uninitialized when used here</span><br><span class="hljs-keyword">auto</span> b;    <span class="hljs-comment">//error: declaration of variable &#x27;b&#x27; with deduced type &#x27;auto&#x27; requires an initializer</span><br><span class="hljs-built_in">cout</span> &lt;&lt; b;<br></code></pre></td></tr></table></figure>

<p>如果使用一个未初始化的普通变量，编译器只会发出<code>warning</code>，仍然可以编译成功，然而运行的结果是未定义的。而如果未初始化一个<code>auto</code>变量会使编译器发出<code>error</code>，则会中断编译过程，这样就强制你使用已初始化的变量。</p>
<p>然而如果你通篇全是<code>auto</code>，可能会显得不直观。虽然在现代IDE中你可以很方便的查看<code>auto</code>推断出的类型，但是这仍然没有直接使用类型直观。所以，<code>auto</code>使用需要自行取舍。</p>
<p>当然<code>auto</code>还有很多使用方法，这里只是简单介绍，如果你有兴趣，你可以通过搜索引擎找到相关内容。</p>
<h3 id="0x04-用C-的方法进行强类型转换"><a href="#0x04-用C-的方法进行强类型转换" class="headerlink" title="0x04 用C++的方法进行强类型转换"></a>0x04 用C++的方法进行强类型转换</h3><p>想想你的老师是怎么教你强类型转换的？是不是这样子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">double</span> a = <span class="hljs-number">123.0</span>;<br><span class="hljs-keyword">int</span> b = (<span class="hljs-keyword">int</span>)a;<br></code></pre></td></tr></table></figure>

<p>够了！停止使用这种旧式强类型转换，使用新式做法，其语法为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">cast-name&lt;type&gt;(expression);<br></code></pre></td></tr></table></figure>

<ul>
<li><code>cast-name</code>为转换的类型，取值有<code>static_cast</code>，<code>dynamic_cast</code>，<code>const_cast</code>和<code>reinterpret_cast</code>。</li>
<li><code>type</code>是要转换成的目标类型</li>
<li><code>expression</code>为进行转换的表达式</li>
</ul>
<p>此处的<em>cast</em>应该被翻译成<em>转型</em>，但我貌似没有找到这个解释。</p>
<p><strong>警告：强类型转换有风险，能不使用就尽量避免使用。</strong></p>
<p>举个栗子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">123</span>;<br><span class="hljs-keyword">double</span> b = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>&gt;(a); <span class="hljs-comment">//a被强类型转化为double</span><br></code></pre></td></tr></table></figure>

<p>旧式转型分别具有和<code>static_cast</code>，<code>const_cast</code>和<code>reinterpret_cast</code>相似的行为，如果出现问题则更难跟踪，所以请不要使用旧式强类型转换。</p>
<p>由于我们是初学者，大部分时候我们只会使用到<code>static_cast</code>，如果对其他的<code>cast</code>有兴趣，可以去搜索引擎寻找答案。</p>
<p><strong>再次警告：能不使用就尽量避免使用强类型转换。</strong></p>
<h3 id="0x05-使用-std-string-而不是-char-数组"><a href="#0x05-使用-std-string-而不是-char-数组" class="headerlink" title="0x05 使用 std::string 而不是 char 数组"></a>0x05 使用 <code>std::string</code> 而不是 <code>char</code> 数组</h3><p>如果你想要用一个字符串，你猜猜学校会教你什么？答对了，是<code>char</code>数组。一个极其难用，又不直观的东西。以下便是例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;   //字符串C库，有些教材还写成#include &quot;string.h&quot;这种C语言写法</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">char</span> str1[<span class="hljs-number">10</span>], str2[<span class="hljs-number">10</span>];<br><span class="hljs-built_in">cin</span> &gt;&gt; str1;         <span class="hljs-comment">//输入字符数组，你猜猜输入字符大于10个会发生什么？</span><br><span class="hljs-built_in">strcpy</span>(str2, str1);	 <span class="hljs-comment">//将str1拷贝到str2中，为什么不能直接用&quot;=&quot;？</span><br><span class="hljs-built_in">strcmp</span>(str1, str2);  <span class="hljs-comment">//比较str1和str2是否一样，为什么不能直接用&quot;==&quot;？</span><br></code></pre></td></tr></table></figure>

<p>使用字符数组会使得代码非常丑陋：</p>
<ol>
<li>如果输入的字符串长度大于数组的长度，可能会造成意想不到的结果，甚至程序崩溃。</li>
<li>使用<code>strcpy()</code>函数拷贝字符串，这个函数有安全风险，而且很不直观。</li>
<li>使用<code>strcmp()</code>比较字符串，很不直观。</li>
</ol>
<p>那么有没有一种“字符串”类型能让我们像使用<code>int</code>、<code>float</code>类型那样使用它呢？有的，<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/string/basic_string"><code>std::string</code></a>就是了。</p>
<p><code>std::string</code>来源于标准库，他是一个字符<strong>容器</strong>，可以<strong>容纳任意个字符</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt; //包含&lt;string&gt;头文件</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-built_in">string</span> str1, str2;<br><span class="hljs-built_in">cin</span> &gt;&gt; str1;     <span class="hljs-comment">//不用担心长度问题</span><br>str2 = str1;     <span class="hljs-comment">//直接赋值即可拷贝</span><br>str2 == str1;    <span class="hljs-comment">//可以直接比较</span><br></code></pre></td></tr></table></figure>

<p>甚至它还有更多的功能：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">str1 = <span class="hljs-string">&quot;Hello World&quot;</span>;<br>str2 = str1.substr(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>);    <span class="hljs-comment">//返回str1从下标0开始长度为5的子串，即&quot;Hello&quot;</span><br><span class="hljs-keyword">char</span> c = str2[<span class="hljs-number">0</span>];           <span class="hljs-comment">//直接取下标返回char元素, 即&#x27;H&#x27;.                     </span><br></code></pre></td></tr></table></figure>

<p>你可以在 <em><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/string/basic_string">CppReference/basic_string</a></em> 里找到<code>std::string</code>的完整文档，这个文档很全也很枯燥，其中<strong>大量涉及初学者不了解的概念</strong>，你也可以配合搜索引擎来解决你的问题。</p>
<h3 id="0x06-动态数组：使用-std-vector"><a href="#0x06-动态数组：使用-std-vector" class="headerlink" title="0x06 动态数组：使用 std::vector"></a>0x06 动态数组：使用 <code>std::vector</code></h3><p>老师可能会跟你讲，数组的长度是固定的，如果你需要在运行时候申请动态长度的数组，可以通过<code>new</code>分配动态内存来实现（我们稍后会讨论这个方法好不好）。</p>
<p>作为一个新手你可能对C++程序的内存模型一无所知，就算老师告诉你，你也是一知半懂。其实你不用纠结，选<code>std::vector</code>就可以解决你的问题。</p>
<p><code>std::vector</code>是标准库里的一种<strong>容器</strong>，他可以<strong>包含任意个数的某一类</strong>元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;  //包含&lt;vector&gt;头文件</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; a;     <span class="hljs-comment">//一个包含元素类型为int的vector</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>*&gt; b; <span class="hljs-comment">//一个包含元素类型为double*的vector</span><br><br>a.push_back(<span class="hljs-number">1</span>);    <span class="hljs-comment">//在末尾添加元素，vector长度会自动增长，此时a[0]即为1</span><br><span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br>a.push_back(b);    <span class="hljs-comment">//此时a[0]为1，a[1]为2</span><br>a.pop_back();      <span class="hljs-comment">//删除末尾元素，此时a长度为1，仅有a[0]为1</span><br>a.empty();         <span class="hljs-comment">//vector为空返回true，否则返回false</span><br>a.size();          <span class="hljs-comment">//返回元素的数量</span><br></code></pre></td></tr></table></figure>

<p>很方便是不是！你完全无需关注内存的分配问题，<code>std::vector</code>自动帮你解决了。事实上，我们可以认为<code>std::string</code>就是一个<code>std::vector&lt;char&gt;</code>。</p>
<p>你可以在 <em><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/vector">CppReference/vector</a></em> 里找到更多关于<code>std::vector</code>的信息，当然这也是个枯燥的说明书，你也可以从搜索引擎中寻找更生动的说明。</p>
<h3 id="0x07-当你使用-using-的时候你到底在做些什么"><a href="#0x07-当你使用-using-的时候你到底在做些什么" class="headerlink" title="0x07 当你使用 using 的时候你到底在做些什么"></a>0x07 当你使用 <code>using</code> 的时候你到底在做些什么</h3><h4 id="一、安全的-using"><a href="#一、安全的-using" class="headerlink" title="一、安全的 using"></a>一、安全的 <code>using</code></h4><p>之前我们写过很多句：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br></code></pre></td></tr></table></figure>

<p>其实这是一种偷懒的写法，这样将会把命名空间<code>std</code>中的所有内容引入进来，而这其中可能会有和你自己命名相冲突的内容。</p>
<p>更安全的方法是用什么就<code>using</code>什么：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>;<br></code></pre></td></tr></table></figure>

<p>或者干脆就不使用<code>using</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> a;<br></code></pre></td></tr></table></figure>

<h4 id="二、用using代替typedef"><a href="#二、用using代替typedef" class="headerlink" title="二、用using代替typedef"></a>二、用<code>using</code>代替<code>typedef</code></h4><p>我们知道<code>typedef</code>可以重新命名一种类型，事实上使用<code>using</code>也可以做到：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> my_int;<br><span class="hljs-keyword">using</span> my_int = <span class="hljs-keyword">int</span>; <span class="hljs-comment">//两者是等价的</span><br></code></pre></td></tr></table></figure>

<p><code>使用using</code>重命名的好处是：<code>using</code>可以对模板进行重命名，而<code>typedef</code>不能。比如如果你想重命名<code>std::string</code>就只能使用<code>using</code>。</p>
<h3 id="0x08-你真的懂循环语句吗"><a href="#0x08-你真的懂循环语句吗" class="headerlink" title="0x08 你真的懂循环语句吗"></a>0x08 你真的懂循环语句吗</h3><p>我们学过的传统循环语句是这样的，以<code>for</code>循环语句为例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(init-statement; condition; expression)<br>    statement<br></code></pre></td></tr></table></figure>

<p>然而事实上我们还可以花式循环。</p>
<h4 id="一、使用迭代器"><a href="#一、使用迭代器" class="headerlink" title="一、使用迭代器"></a>一、使用迭代器</h4><p>STL中的容器几乎都有<strong>迭代器</strong>，迭代器是个很复杂的概念，我们只需要会简单使用即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; a = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;                  <span class="hljs-comment">//a中有三个元素，分别为1,2,3</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i = a.begin(); i != a.end(); i++)	<span class="hljs-comment">//a.begin()和a.end()分别是起始、终止迭代器</span><br>        <span class="hljs-built_in">cout</span> &lt;&lt; *i;	                            <span class="hljs-comment">//解引用即为当前元素</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="二、使用基于范围的-for-循环"><a href="#二、使用基于范围的-for-循环" class="headerlink" title="二、使用基于范围的 for 循环"></a>二、使用基于范围的 <code>for</code> 循环</h4><p>更好用的是基于范围的<code>for</code>循环，我们写一个挨个输出<code>std:string</code>里字符的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;abcdef&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;i: str)<br>        <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>基于范围的<code>for</code>的括号内包含两部分。<code>:</code>左边是一个变量声明，序列中元素会挨个转换成这个和这个变量的类型。为了保证转换成功，我们使用<code>auto</code>来推测类型。<code>:</code>的右边则是个序列，比如像原生数组、<code>std::vector</code>和<code>std::string</code>都可以作为序列。</p>
<p>循环会将序列中的元素一一取出，然后赋值给变量。注意我们在声明中使用了引用类型<code>&amp;i</code>，它能让你修改序列中的元素。你可以做一个实验：把<code>&amp;i</code>改成<code>i</code>，然后在循环中修改元素，看看会发生什么。</p>
<h3 id="0x09-引用是个好东西"><a href="#0x09-引用是个好东西" class="headerlink" title="0x09 引用是个好东西"></a>0x09 引用是个好东西</h3><p>想想老师一定教你写过交换两个数的函数<code>swap()</code>，他们往往教你用指针实现，比如交换两个整数的函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* a, <span class="hljs-keyword">int</span>* b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> temp = *a;<br>    *a = *b;<br>    *b = temp;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这很好理解，但我们其实可以用引用来实现这个函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; a, <span class="hljs-keyword">int</span>&amp; b)</span>   <span class="hljs-comment">//int&amp;表示是一个int值的引用</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> temp = a;           <span class="hljs-comment">//引用使用方法和值一样，无需使用*解引用</span><br>    a = b;<br>    b = temp;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样看来使用引用实现的<code>swap()</code>更加直观，不用反复使用<code>*</code>。</p>
<p>引用和指针一样，可以直接接触到原数据，而不用担心值的拷贝问题，这一特性往往用在函数参数上。比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> str)</span></span>;  <span class="hljs-comment">//参数传值，会经历一次拷贝过程</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;str)</span></span>; <span class="hljs-comment">//传引用不会进行拷贝</span><br></code></pre></td></tr></table></figure>

<p>如果使用传值的方式调用函数，则会用原来的字符串生成一个新字符串str，如果字符串很大，或者这个函数被调用多次，则这个拷贝花费的时间就会很长。</p>
<p>而传引用不存在这个问题，函数传递的是原来的数据对象，不会进行拷贝。</p>
<p>当然引用也有一些弊端和局限，在此就不多讲了。</p>
<h3 id="0x0A-一步步来：从面向过程到面向对象"><a href="#0x0A-一步步来：从面向过程到面向对象" class="headerlink" title="0x0A 一步步来：从面向过程到面向对象"></a>0x0A 一步步来：从面向过程到面向对象</h3><p>在学校的教学当中，从面相过程到面向对象是一蹴而就的。然而并没有几个人听得懂他们在讲什么。为什么要使用面向对象？从面相过程如何转换到面向对象？一概不知。</p>
<p>这里我将一步步带领你理解这个转换过程。从一个小故事开始。</p>
<p>老王开了个饭馆，每天要进货各种食材，而他每天都算账算的焦头烂额，于是他打算写一个程序来帮他算账。</p>
<h4 id="一、面向过程的问题"><a href="#一、面向过程的问题" class="headerlink" title="一、面向过程的问题"></a>一、面向过程的问题</h4><p>老王先写了一个大致的框架：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">buy</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span></span>; <span class="hljs-comment">//money为原来的钱</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> money;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; money;<br>    <span class="hljs-keyword">int</span> leftMoney = buy(money); <span class="hljs-comment">//leftMoney为剩下的钱</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后他开始填充这个框架：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> porkMoney = <span class="hljs-number">50</span>, chickenMoney = <span class="hljs-number">10</span> ...;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">buy</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money, <span class="hljs-keyword">int</span> porkNumber, <span class="hljs-keyword">int</span> chickenNumber ...)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> money - porkNumber*porkMoney - chickenNumber*chickenMoney ...;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>他发现了一个问题，随着他购入商品品种的增加，他传入的参数也在增加。为了把店里所有的食材容纳进去，他不得不给函数加上几十个参数！这实在又臭又长。</p>
<h4 id="二、使用-struct-：面向对象的雏形"><a href="#二、使用-struct-：面向对象的雏形" class="headerlink" title="二、使用 struct ：面向对象的雏形"></a>二、使用 <code>struct</code> ：面向对象的雏形</h4><p>这时候老王想了个办法：可以把这些商品归在一类事物下。于是他开始使用<code>struct</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">goods</span></span><br><span class="hljs-class">&#123;</span><br>	<span class="hljs-keyword">int</span> chicken;<br>	<span class="hljs-keyword">int</span> pork;<br>	...<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">money</span></span><br><span class="hljs-class">&#123;</span><br>	<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> chicken = <span class="hljs-number">10</span>;<br>	<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> pork = <span class="hljs-number">50</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">buy</span><span class="hljs-params">(goods todayGoods)</span></span>;<br></code></pre></td></tr></table></figure>

<p>这回不用传递一大坨参数，显得十分美观，老王非常满意。</p>
<p>事实上，这种把事物<strong>归类</strong>的思想，就是面向对象的雏形。</p>
<h4 id="三、改用-class-试试"><a href="#三、改用-class-试试" class="headerlink" title="三、改用 class 试试"></a>三、改用 <code>class</code> 试试</h4><p>过了几天，老王感觉支出无故变多了。他检查了一下代码，发现食材的数目是对的上，然而价格被人为改了，鸡比猪贵！有人以此中饱私囊！他很生气，但是苦于店内人手短缺，他又不敢随意怀疑别人。</p>
<p>于是这次他转用<code>class</code>, 在C++中<code>class</code>和<code>struct</code>几乎没有区别，唯一的区别是<code>class</code>的默认成员为<code>private</code>而后者为<code>public</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Goods</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setPorkNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>;        <span class="hljs-comment">//让外人调用set...Number()设置数量</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setChickenNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>;<br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">buy</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span></span>&#123;                    <span class="hljs-comment">//外人调用buy()来购买</span><br>        <span class="hljs-keyword">if</span>(checkEveryIsOK())               <span class="hljs-comment">//购买前检查一切是否安好</span><br>        <span class="hljs-keyword">return</span> money...;<br>    &#125;<br><span class="hljs-keyword">private</span>:                                   <span class="hljs-comment">//把变量设为私有，让外人不能随意修改，修改必须</span><br>    <span class="hljs-keyword">int</span> porkNumber = <span class="hljs-number">0</span>;                    <span class="hljs-comment">//通过set...Number()，而且buy()之前还有检查</span><br>    <span class="hljs-keyword">int</span> setNumber = <span class="hljs-number">0</span>;<br>    ...<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> porkMoney = <span class="hljs-number">50</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> chickenMoney = <span class="hljs-number">10</span>;<br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">checkEveryIsOK</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p>老王把这个类的实现编译出来，然后交给别人来使用，自己把源代码藏了起来，由此他成功的控制了店内的食材进货过程。</p>
<p>这个故事告诉我们，一个良好的类需要区分可以被人操作的部分，和不能被人触碰到的部分。在别人通过我们公开的函数修改不能被触碰到的部分时，我们可以对他的修改进行检查，合理的修改才予以执行。</p>
<p>即便程序是一个人完成的，这样的限制也是有必要的。类的访问限制可以让你不会随意的修改数据，至于与在恍惚中造成错误。而这是面向过程所难以做的。</p>
<p>而面向对象可以适应更大型的程序，比如那些需要多人协作完成的程序，良好的限制才能使配合更加紧密。</p>
<p>而面向对象还不只这些功能，它的功能还有比如<strong>继承、多态</strong>，这些教材中都有，我就不再赘述。</p>
<h3 id="0x0B-使用智能指针而不是手动-new-delete-管理动态内存"><a href="#0x0B-使用智能指针而不是手动-new-delete-管理动态内存" class="headerlink" title="0x0B 使用智能指针而不是手动 new/delete 管理动态内存"></a>0x0B 使用智能指针而不是手动 <code>new/delete</code> 管理动态内存</h3><p>如果我们需要使用大量的内存，或者是在运行时进行动态内存分配，老师都会教我们使用<code>new/delete</code>手动管理内存。而这对新手是一件难事，甚至很多C++老手都苦于手动管理内存。动态申请内存和普通变量所占的内存不同，普通变量占的内存会自动释放，而申请的内存必须手动释放。</p>
<p>在课堂上，我们学过一段内存<code>new</code>分配之后一定要<code>delete</code>释放，然而加入忘记<code>delete</code>怎么办？你说你肯定不会忘，然后写了下面这段代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span>* a;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>&#123;<br>    a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(i);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; *a;<br>&#125;<br><span class="hljs-keyword">delete</span> a;<br></code></pre></td></tr></table></figure>

<p>你说：你看我记得<code>delete</code>了啊，快夸我！可是你仔细看看，在循环中的前两次<code>new</code>出的内存都没有被释放，这造成了内存泄漏。</p>
<p>事实上，当程序复杂起来，无数人用经验证明：忘记<code>delete</code>事件时有发生。</p>
<p>而内存泄漏其实还不是最危险的，更危险的是<em>悬挂指针</em>问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> *a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;<br><span class="hljs-keyword">delete</span> a;<br><span class="hljs-built_in">cout</span> &lt;&lt; *a;    <span class="hljs-comment">//此时a就是一个悬挂指针，直接访问他可能造成程序崩溃！</span><br></code></pre></td></tr></table></figure>

<p><em>悬挂指针</em>指的是那些指向的内存已经被<code>delete</code>的指针，此时的正确做法应该是赶快将这个指针重置为<code>nullptr</code>，来防止他进行其他操作。但是有时候这个指针的使用者可能不知道指向的内存已经释放，比如使用者调用了一个函数，这个函数释放了这个指针指向的内存，但是使用者不一定知道。</p>
<p><em>Modern C++</em> 推荐我们使用智能指针来代替手动管理内存，智能指针定义在头文件<code>&lt;memory&gt;</code>当中。</p>
<p>智能指针的作用是，当他们的生命周期结束时，他们会自动释放指向的内存。而智能指针的使用方式和普通指针无异。</p>
<p>智能指针包括三种<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/memory/unique_ptr"><code>std::unique_ptr</code></a>、<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/memory/shared_ptr"><code>std::shared_ptr</code></a>和<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/memory/weak_ptr"><code>std::weak_ptr</code></a>，我们将着重讨论前两种。</p>
<h4 id="一、独占指针：std-unique-ptr"><a href="#一、独占指针：std-unique-ptr" class="headerlink" title="一、独占指针：std::unique_ptr"></a>一、独占指针：<code>std::unique_ptr</code></h4><p><code>std::unique_ptr</code>表示只有单一变量持有这个指针，对这个指针进行拷贝是禁止的，你只能<em>移动</em>这个指针（这个操作不适合新手，故不在本文的讨论范围）。你可以通过<code>std::make_unique</code>来创建一个<code>std::unique_ptr</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">auto</span> p = make_unique&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">123</span>); <span class="hljs-comment">//动态分配一块int大小的内存，并将指针指向这块内存，将初值设为123</span><br><span class="hljs-keyword">auto</span> q = p;                     <span class="hljs-comment">//编译错误，不能复制一个std::unique_ptr</span><br><span class="hljs-keyword">int</span> b = <span class="hljs-number">321</span> + *p;               <span class="hljs-comment">//像使用普通指针一样使用智能指针。</span><br></code></pre></td></tr></table></figure>

<h4 id="二、共享指针：std-shared-ptr"><a href="#二、共享指针：std-shared-ptr" class="headerlink" title="二、共享指针：std::shared_ptr"></a>二、共享指针：<code>std::shared_ptr</code></h4><p><code>std::shared_ptr</code>则可以复制多次，其内部有一个计数器，复制一次便<code>+1</code>，有一个指针被销毁则<code>-1</code>，当计数器为0时则释放指向的内存。我们使用<code>std::make_shared</code>构造一个<code>std::shared_ptr</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">auto</span> p = make_shared&lt;<span class="hljs-keyword">char</span>&gt;(<span class="hljs-string">&#x27;a&#x27;</span>); <span class="hljs-comment">//动态分配一块char大小的内存，并将指针指向这块内存，将初值设为&#x27;a&#x27;</span><br><span class="hljs-keyword">auto</span> q = p;                     <span class="hljs-comment">//可以复制一个std::shared_ptr，此时计数器为2</span><br>*p = <span class="hljs-string">&#x27;b&#x27;</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; *p &lt;&lt; *q;               <span class="hljs-comment">//输出bb</span><br></code></pre></td></tr></table></figure>

<p>使用智能指针可以避免手动管理内存，这是一个利器。然而智能指针可能引入其他问题，比如<code>std::shared_ptr</code>可能造成<em>循环引用</em>问题，这些都需要你自行了解并解决。</p>
<h3 id="0x0C-尝试使用异常"><a href="#0x0C-尝试使用异常" class="headerlink" title="0x0C 尝试使用异常"></a>0x0C 尝试使用异常</h3><p>你还记不记得<code>main()</code>函数的<code>return 0;</code>语句表示什么意思？老师可能讲过，如果程序正常退出将会返回<code>0</code>，而不正常退出则会返回其他值。而这个返回值是做什么用的呢？</p>
<p>让我们来编写这样一个函数，让用户输入一个字符，只有这个字符是数字的时候才返回对应的数字，否则都返回<code>-1</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">input</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> ch;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; ch;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-string">&#x27;0&#x27;</span> &lt;= ch &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)<br>        <span class="hljs-keyword">return</span> ch - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>而如果我们调用这个函数，函数返回了<code>-1</code>，我们就知道用户输入的不是数字，可能是一个错误的输入。这样的机制称为<strong>错误码机制</strong>，即设定某些返回值代表<strong>处理错误</strong>，如果得到这个返回值，我们就可以对错误进行处理。</p>
<p>然而假如函数嵌套了很多层，当最里层的函数触发错误时，它必须一路返回到最上层处理错误，或者你不得不在每一层加入错误处理的代码。然而这样的做法并不优雅。</p>
<p>这时候我们就可以使用C++的错误处理机制。我们可以用<code>throw</code>抛出错误：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">input</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ...;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-string">&#x27;0&#x27;</span> &lt;= ch &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)<br>        <span class="hljs-keyword">return</span> ch - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">throw</span> ch;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>无论这个函数嵌套了多少层，<code>throw</code>抛出的错误一定能被最上层直接接收到，而且如果你不处理错误的话，<code>throw</code>会直接中断程序——如果你使用错误码机制，你可以选择忽略错误码，这样相当于抱病运行。</p>
<p>我们可以使用<code>try..catch...</code>来处理错误：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">try</span>&#123;<br>    input();         <span class="hljs-comment">//把有可能抛出错误的代码放到try块中</span><br>&#125;<span class="hljs-keyword">catch</span>(<span class="hljs-keyword">char</span> ch)&#123;     <span class="hljs-comment">//catch会捕捉到数据类型相同的异常</span><br>    ...;             <span class="hljs-comment">//处理异常</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>C++异常机制将强迫你处理异常，并且无需层层回调即可处理，当然，他也会衍生其他的问题，这些需要你自行了解。</p>
<p>本文到此结束，希望读者对<em>Modern C++</em> 有一个大致的认识，并且能使用它来写代码。如果想要更深入学习C++ ，可以从STL入手，C++还有许许多多的内容等待你探索。</p>
<p>参考：</p>
<ul>
<li><em>C++ Primer 5th</em></li>
<li><em>Think in C++</em></li>
<li><em>Effective C++</em></li>
</ul>
</div></article><div class="post-view__sidebar"><div class="sidebar"><div class="tocbot"><h2>Toc</h2><div class="toc__content"></div></div><h2>Links</h2><div class="sidebar__link"><ul><li><a target="_blank" rel="noopener" href="https://github.com/arrayJY">Github</a></li><li><a target="_blank" rel="noopener" href="https://www.zhihu.com/people/arrayJY">知乎</a></li><li><a href="mailto:arrayjy@outlook.com">Mail</a></li></ul></div><h2>Archives</h2><div class="sidebar__archives"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a></li></ul></div><h2>Categories</h2><div class="sidebar__categories"></div><h2>Tags</h2><div class="sidebar__tags"></div></div></div></div><div class="horizontal-line" style="height: 1px"></div><div class="main__bottom"><div class="pre-next"><a class="pre-button">没有更多</a><a class="next-button">没有更多</a></div></div></div></div><div class="footer"><span>©️2019-2020 Designed By&nbsp;<strong><a target="_blank" rel="noopener" href="https://github.com/random-yang">RandomYang</a></strong> Powered By&nbsp;</span><strong><a target="_blank" rel="noopener" href="https://hexo.io">hexo</a></strong></div><div class="darkmode-mask" id="darkmode-mask"></div><div class="sidebar__button"></div></body></html>